{
  "tasks": [
    {
      "topic": "Django",
      "subtopic": "Models",
      "description": "Understanding Django Model inheritance behavior",
      "difficulty": "medium",
      "translations": [
        {
          "language": "en",
          "question": "from django.db import models\n\nclass Animal(models.Model):\n    name = models.CharField(max_length=100)\n    species = models.CharField(max_length=50)\n    \n    class Meta:\n        abstract = True\n\nclass Dog(Animal):\n    breed = models.CharField(max_length=50)\n\ndog = Dog(name=\"Buddy\", species=\"Canine\", breed=\"Golden Retriever\")\nprint(hasattr(dog, 'animal_ptr'))",
          "answers": ["True", "False", "Error"],
          "correct_answer": "False",
          "explanation": "Abstract base models don't create a separate table or foreign key relationship. The 'animal_ptr' attribute only exists in multi-table inheritance."
        },
        {
          "language": "ru",
          "question": "from django.db import models\n\nclass Animal(models.Model):\n    name = models.CharField(max_length=100)\n    species = models.CharField(max_length=50)\n    \n    class Meta:\n        abstract = True\n\nclass Dog(Animal):\n    breed = models.CharField(max_length=50)\n\ndog = Dog(name=\"Buddy\", species=\"Canine\", breed=\"Golden Retriever\")\nprint(hasattr(dog, 'animal_ptr'))",
          "answers": ["True", "False", "Ошибка"],
          "correct_answer": "False",
          "explanation": "Абстрактные базовые модели не создают отдельную таблицу или связь по внешнему ключу. Атрибут 'animal_ptr' существует только при многотабличном наследовании."
        },
        {
          "language": "tr",
          "question": "from django.db import models\n\nclass Animal(models.Model):\n    name = models.CharField(max_length=100)\n    species = models.CharField(max_length=50)\n    \n    class Meta:\n        abstract = True\n\nclass Dog(Animal):\n    breed = models.CharField(max_length=50)\n\ndog = Dog(name=\"Buddy\", species=\"Canine\", breed=\"Golden Retriever\")\nprint(hasattr(dog, 'animal_ptr'))",
          "answers": ["True", "False", "Hata"],
          "correct_answer": "False",
          "explanation": "Soyut temel modeller ayrı bir tablo veya yabancı anahtar ilişkisi oluşturmaz. 'animal_ptr' özniteliği yalnızca çoklu tablo kalıtımında bulunur."
        },
        {
          "language": "ar",
          "question": "from django.db import models\n\nclass Animal(models.Model):\n    name = models.CharField(max_length=100)\n    species = models.CharField(max_length=50)\n    \n    class Meta:\n        abstract = True\n\nclass Dog(Animal):\n    breed = models.CharField(max_length=50)\n\ndog = Dog(name=\"Buddy\", species=\"Canine\", breed=\"Golden Retriever\")\nprint(hasattr(dog, 'animal_ptr'))",
          "answers": ["True", "False", "خطأ"],
          "correct_answer": "False",
          "explanation": "النماذج الأساسية المجردة لا تنشئ جدولاً منفصلاً أو علاقة مفتاح خارجي. الخاصية 'animal_ptr' موجودة فقط في الوراثة متعددة الجداول."
        }
      ]
    },
    {
      "topic": "Django",
      "subtopic": "Views",
      "description": "Django Class-Based View behavior",
      "difficulty": "medium",
      "translations": [
        {
          "language": "en",
          "question": "from django.views.generic import ListView\nfrom django.db import models\n\nclass Article(models.Model):\n    title = models.CharField(max_length=200)\n    published = models.BooleanField(default=True)\n\nclass ArticleListView(ListView):\n    model = Article\n    context_object_name = 'articles'\n\n# What is the default template name Django will look for?",
          "answers": ["article_list.html", "articles_list.html", "article/list.html"],
          "correct_answer": "article_list.html",
          "explanation": "Django automatically generates template names for ListView using the pattern: app_name/model_name_list.html"
        },
        {
          "language": "ru",
          "question": "from django.views.generic import ListView\nfrom django.db import models\n\nclass Article(models.Model):\n    title = models.CharField(max_length=200)\n    published = models.BooleanField(default=True)\n\nclass ArticleListView(ListView):\n    model = Article\n    context_object_name = 'articles'\n\n# Какое имя шаблона Django будет искать по умолчанию?",
          "answers": ["article_list.html", "articles_list.html", "article/list.html"],
          "correct_answer": "article_list.html",
          "explanation": "Django автоматически генерирует имена шаблонов для ListView по паттерну: app_name/model_name_list.html"
        },
        {
          "language": "tr",
          "question": "from django.views.generic import ListView\nfrom django.db import models\n\nclass Article(models.Model):\n    title = models.CharField(max_length=200)\n    published = models.BooleanField(default=True)\n\nclass ArticleListView(ListView):\n    model = Article\n    context_object_name = 'articles'\n\n# Django varsayılan olarak hangi şablon adını arayacak?",
          "answers": ["article_list.html", "articles_list.html", "article/list.html"],
          "correct_answer": "article_list.html",
          "explanation": "Django, ListView için şablon adlarını otomatik olarak şu kalıba göre oluşturur: app_name/model_name_list.html"
        },
        {
          "language": "ar",
          "question": "from django.views.generic import ListView\nfrom django.db import models\n\nclass Article(models.Model):\n    title = models.CharField(max_length=200)\n    published = models.BooleanField(default=True)\n\nclass ArticleListView(ListView):\n    model = Article\n    context_object_name = 'articles'\n\n# ما هو اسم القالب الافتراضي الذي سيبحث عنه Django؟",
          "answers": ["article_list.html", "articles_list.html", "article/list.html"],
          "correct_answer": "article_list.html",
          "explanation": "يقوم Django تلقائياً بإنشاء أسماء القوالب لـ ListView باستخدام النمط: app_name/model_name_list.html"
        }
      ]
    },
    {
      "topic": "Django",
      "subtopic": "Forms",
      "description": "Django ModelForm validation behavior",
      "difficulty": "medium",
      "translations": [
        {
          "language": "en",
          "question": "from django import forms\nfrom django.db import models\n\nclass User(models.Model):\n    email = models.EmailField(unique=True)\n    age = models.IntegerField()\n\nclass UserForm(forms.ModelForm):\n    class Meta:\n        model = User\n        fields = ['email', 'age']\n    \n    def clean_age(self):\n        age = self.cleaned_data['age']\n        if age < 13:\n            raise forms.ValidationError(\"Age must be at least 13\")\n        return age\n\nform = UserForm({'email': 'test@example.com', 'age': '10'})\nprint(form.is_valid())",
          "answers": ["True", "False", "Error"],
          "correct_answer": "False",
          "explanation": "The custom clean_age() method raises a ValidationError for age < 13, making the form invalid."
        },
        {
          "language": "ru",
          "question": "from django import forms\nfrom django.db import models\n\nclass User(models.Model):\n    email = models.EmailField(unique=True)\n    age = models.IntegerField()\n\nclass UserForm(forms.ModelForm):\n    class Meta:\n        model = User\n        fields = ['email', 'age']\n    \n    def clean_age(self):\n        age = self.cleaned_data['age']\n        if age < 13:\n            raise forms.ValidationError(\"Age must be at least 13\")\n        return age\n\nform = UserForm({'email': 'test@example.com', 'age': '10'})\nprint(form.is_valid())",
          "answers": ["True", "False", "Ошибка"],
          "correct_answer": "False",
          "explanation": "Пользовательский метод clean_age() выбрасывает ValidationError для возраста < 13, делая форму невалидной."
        },
        {
          "language": "tr",
          "question": "from django import forms\nfrom django.db import models\n\nclass User(models.Model):\n    email = models.EmailField(unique=True)\n    age = models.IntegerField()\n\nclass UserForm(forms.ModelForm):\n    class Meta:\n        model = User\n        fields = ['email', 'age']\n    \n    def clean_age(self):\n        age = self.cleaned_data['age']\n        if age < 13:\n            raise forms.ValidationError(\"Age must be at least 13\")\n        return age\n\nform = UserForm({'email': 'test@example.com', 'age': '10'})\nprint(form.is_valid())",
          "answers": ["True", "False", "Hata"],
          "correct_answer": "False",
          "explanation": "Özel clean_age() metodu yaş < 13 için ValidationError fırlatır, bu da formu geçersiz kılar."
        },
        {
          "language": "ar",
          "question": "from django import forms\nfrom django.db import models\n\nclass User(models.Model):\n    email = models.EmailField(unique=True)\n    age = models.IntegerField()\n\nclass UserForm(forms.ModelForm):\n    class Meta:\n        model = User\n        fields = ['email', 'age']\n    \n    def clean_age(self):\n        age = self.cleaned_data['age']\n        if age < 13:\n            raise forms.ValidationError(\"Age must be at least 13\")\n        return age\n\nform = UserForm({'email': 'test@example.com', 'age': '10'})\nprint(form.is_valid())",
          "answers": ["True", "False", "خطأ"],
          "correct_answer": "False",
          "explanation": "الطريقة المخصصة clean_age() تُثير ValidationError للعمر < 13، مما يجعل النموذج غير صالح."
        }
      ]
    },
    {
      "topic": "Django",
      "subtopic": "ORM",
      "description": "Django QuerySet evaluation and caching",
      "difficulty": "hard",
      "translations": [
        {
          "language": "en",
          "question": "from django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n    price = models.DecimalField(max_digits=10, decimal_places=2)\n\n# Assume database has 3 products\nqueryset = Product.objects.filter(price__gt=100)\nprint(len(queryset))  # Line 1\nprint(len(queryset))  # Line 2\n\n# How many database queries are executed?",
          "answers": ["1", "2", "3"],
          "correct_answer": "1",
          "explanation": "QuerySets are cached after first evaluation. The first len() triggers a database query and caches results. The second len() uses cached data."
        },
        {
          "language": "ru",
          "question": "from django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n    price = models.DecimalField(max_digits=10, decimal_places=2)\n\n# Предположим, в базе данных 3 продукта\nqueryset = Product.objects.filter(price__gt=100)\nprint(len(queryset))  # Строка 1\nprint(len(queryset))  # Строка 2\n\n# Сколько запросов к базе данных будет выполнено?",
          "answers": ["1", "2", "3"],
          "correct_answer": "1",
          "explanation": "QuerySet кэшируются после первого выполнения. Первый len() запускает запрос к базе и кэширует результаты. Второй len() использует кэшированные данные."
        },
        {
          "language": "tr",
          "question": "from django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n    price = models.DecimalField(max_digits=10, decimal_places=2)\n\n# Veritabanında 3 ürün olduğunu varsayalım\nqueryset = Product.objects.filter(price__gt=100)\nprint(len(queryset))  # Satır 1\nprint(len(queryset))  # Satır 2\n\n# Kaç veritabanı sorgusu yürütülür?",
          "answers": ["1", "2", "3"],
          "correct_answer": "1",
          "explanation": "QuerySet'ler ilk değerlendirmeden sonra önbelleğe alınır. İlk len() veritabanı sorgusunu tetikler ve sonuçları önbelleğe alır. İkinci len() önbelleğe alınmış verileri kullanır."
        },
        {
          "language": "ar",
          "question": "from django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n    price = models.DecimalField(max_digits=10, decimal_places=2)\n\n# افترض أن قاعدة البيانات تحتوي على 3 منتجات\nqueryset = Product.objects.filter(price__gt=100)\nprint(len(queryset))  # السطر 1\nprint(len(queryset))  # السطر 2\n\n# كم عدد استعلامات قاعدة البيانات التي سيتم تنفيذها؟",
          "answers": ["1", "2", "3"],
          "correct_answer": "1",
          "explanation": "يتم تخزين QuerySets مؤقتاً بعد التقييم الأول. أول len() يطلق استعلام قاعدة البيانات ويخزن النتائج مؤقتاً. الثاني len() يستخدم البيانات المخزنة مؤقتاً."
        }
      ]
    },
    {
      "topic": "Django",
      "subtopic": "Middleware",
      "description": "Django middleware execution order",
      "difficulty": "hard",
      "translations": [
        {
          "language": "en",
          "question": "# settings.py\nMIDDLEWARE = [\n    'middleware.FirstMiddleware',\n    'middleware.SecondMiddleware',\n    'middleware.ThirdMiddleware',\n]\n\n# Each middleware has process_request and process_response methods\n# A request comes in and gets a response\n# In what order are process_response methods called?",
          "answers": ["First, Second, Third", "Third, Second, First", "Random order"],
          "correct_answer": "Third, Second, First",
          "explanation": "Django middleware process_response methods are called in reverse order compared to process_request methods."
        },
        {
          "language": "ru",
          "question": "# settings.py\nMIDDLEWARE = [\n    'middleware.FirstMiddleware',\n    'middleware.SecondMiddleware',\n    'middleware.ThirdMiddleware',\n]\n\n# Каждый middleware имеет методы process_request и process_response\n# Приходит запрос и получается ответ\n# В каком порядке вызываются методы process_response?",
          "answers": ["First, Second, Third", "Third, Second, First", "Случайный порядок"],
          "correct_answer": "Third, Second, First",
          "explanation": "Методы process_response в Django middleware вызываются в обратном порядке по сравнению с методами process_request."
        },
        {
          "language": "tr",
          "question": "# settings.py\nMIDDLEWARE = [\n    'middleware.FirstMiddleware',\n    'middleware.SecondMiddleware',\n    'middleware.ThirdMiddleware',\n]\n\n# Her middleware'in process_request ve process_response metodları var\n# Bir istek gelir ve bir yanıt alınır\n# process_response metodları hangi sırayla çağrılır?",
          "answers": ["First, Second, Third", "Third, Second, First", "Rastgele sıra"],
          "correct_answer": "Third, Second, First",
          "explanation": "Django middleware process_response metodları, process_request metodlarına kıyasla ters sırada çağrılır."
        },
        {
          "language": "ar",
          "question": "# settings.py\nMIDDLEWARE = [\n    'middleware.FirstMiddleware',\n    'middleware.SecondMiddleware',\n    'middleware.ThirdMiddleware',\n]\n\n# كل middleware له طرق process_request و process_response\n# يأتي طلب ويتم الحصول على استجابة\n# بأي ترتيب يتم استدعاء طرق process_response؟",
          "answers": ["First, Second, Third", "Third, Second, First", "ترتيب عشوائي"],
          "correct_answer": "Third, Second, First",
          "explanation": "يتم استدعاء طرق process_response في Django middleware بترتيب عكسي مقارنة بطرق process_request."
        }
      ]
    },
    {
      "topic": "Django",
      "subtopic": "Templates",
      "description": "Django template context and variable resolution",
      "difficulty": "medium",
      "translations": [
        {
          "language": "en",
          "question": "# Template: template.html\n{{ user.name.upper }}\n\n# Context:\ncontext = {\n    'user': {\n        'name': 'alice',\n        'age': 25\n    }\n}\n\n# What will be rendered?",
          "answers": ["ALICE", "alice.upper", "AttributeError"],
          "correct_answer": "AttributeError",
          "explanation": "Django template variables can't call methods on dictionary values. 'user' is a dict, so 'user.name' is 'alice' (string), and strings don't have 'upper' attribute in template context."
        },
        {
          "language": "ru",
          "question": "# Шаблон: template.html\n{{ user.name.upper }}\n\n# Контекст:\ncontext = {\n    'user': {\n        'name': 'alice',\n        'age': 25\n    }\n}\n\n# Что будет отображено?",
          "answers": ["ALICE", "alice.upper", "AttributeError"],
          "correct_answer": "AttributeError",
          "explanation": "Переменные шаблона Django не могут вызывать методы на значениях словаря. 'user' - это словарь, поэтому 'user.name' это 'alice' (строка), и строки не имеют атрибута 'upper' в контексте шаблона."
        },
        {
          "language": "tr",
          "question": "# Şablon: template.html\n{{ user.name.upper }}\n\n# Bağlam:\ncontext = {\n    'user': {\n        'name': 'alice',\n        'age': 25\n    }\n}\n\n# Ne render edilecek?",
          "answers": ["ALICE", "alice.upper", "AttributeError"],
          "correct_answer": "AttributeError",
          "explanation": "Django şablon değişkenleri sözlük değerlerinde metod çağıramaz. 'user' bir sözlüktür, bu yüzden 'user.name' 'alice' (string) olur ve stringlerin şablon bağlamında 'upper' özniteliği yoktur."
        },
        {
          "language": "ar",
          "question": "# القالب: template.html\n{{ user.name.upper }}\n\n# السياق:\ncontext = {\n    'user': {\n        'name': 'alice',\n        'age': 25\n    }\n}\n\n# ماذا سيتم عرضه؟",
          "answers": ["ALICE", "alice.upper", "AttributeError"],
          "correct_answer": "AttributeError",
          "explanation": "متغيرات قالب Django لا يمكنها استدعاء طرق على قيم القاموس. 'user' هو قاموس، لذا 'user.name' هو 'alice' (نص)، والنصوص ليس لها خاصية 'upper' في سياق القالب."
        }
      ]
    }
  ]
}