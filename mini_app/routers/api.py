import json
import logging
import httpx
import os
import urllib.parse
import re
import logging
import json
import hmac
import hashlib

from fastapi import APIRouter, Request, Response, UploadFile, File, HTTPException, Depends
from fastapi.responses import JSONResponse, PlainTextResponse
from pydantic import BaseModel, Field, ValidationError
from telegram_webapp_auth.auth import TelegramAuthenticator
from telegram_webapp_auth.errors import InvalidInitDataError, ExpiredInitDataError

from core.config import settings
from services.django_api_service import django_api_service
from aiohttp import ClientResponseError

router = APIRouter(prefix="/api")
logger = logging.getLogger(__name__)

class InitDataModel(BaseModel):
    initData: str = Field(..., alias='initData')

class UserProfileRequest(BaseModel):
    initData: str = Field(..., alias='initData')

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")

if not TELEGRAM_BOT_TOKEN:
    raise ValueError("TELEGRAM_BOT_TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è.")

authenticator = TelegramAuthenticator(
    secret=TELEGRAM_BOT_TOKEN.encode(),
    #ttl_seconds=3600 # –£–±—Ä–∞–ª –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
)

@router.post("/verify-init-data")
async def verify_init_data(request: Request):
    """
    –ü—Ä–∏–Ω–∏–º–∞–µ—Ç initData –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞, –±–µ–∑–æ–ø–∞—Å–Ω–æ –≤–∞–ª–∏–¥–∏—Ä—É–µ—Ç –ø–æ–¥–ø–∏—Å—å
    –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª—è –∏–∑ –Ω–∞—à–µ–≥–æ –±—ç–∫–µ–Ω–¥–∞.
    """
    logger.info(f"üöÄ –ù–ê–ß–ê–õ–û –û–ë–†–ê–ë–û–¢–ö–ò /verify-init-data")
    logger.info(f"üîç User-Agent: {request.headers.get('user-agent', 'Unknown')}")
    logger.info(f"üîç X-Forwarded-For: {request.headers.get('x-forwarded-for', 'Unknown')}")
    logger.info(f"üîç Referer: {request.headers.get('referer', 'Unknown')}")
    try:
        data = await request.json()
        init_data_str = data.get('initData')

        # –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        logger.info(f"–ü–æ–ª—É—á–µ–Ω initData (–ø–µ—Ä–≤—ã–µ 100 —Å–∏–º–≤–æ–ª–æ–≤): {init_data_str[:100] if init_data_str else 'None'}")
        logger.info(f"–î–ª–∏–Ω–∞ initData: {len(init_data_str) if init_data_str else 0}")

        if not init_data_str:
            logger.error("–í –∑–∞–ø—Ä–æ—Å–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç initData")
            raise HTTPException(status_code=400, detail="initData is missing")

        if not settings.TELEGRAM_BOT_TOKEN:
            logger.error("TELEGRAM_BOT_TOKEN –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ")
            raise HTTPException(status_code=500, detail="Bot token is not configured on the server.")

        # –ü–†–ê–í–ò–õ–¨–ù–ê–Ø –í–ê–õ–ò–î–ê–¶–ò–Ø:
        # –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–µ–º —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á –ø–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ Telegram
        secret_key = hmac.new(
            key=b"WebAppData", 
            msg=settings.TELEGRAM_BOT_TOKEN.encode(), 
            digestmod=hashlib.sha256
        ).digest()
        
        # –ü—ã—Ç–∞–µ–º—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫—É –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
        try:
            auth = TelegramAuthenticator(secret=secret_key)
            init_data = auth.validate(init_data_str)
        except Exception as lib_error:
            logger.warning(f"–û—à–∏–±–∫–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {lib_error}")
            logger.info("–ü—Ä–æ–±—É–µ–º —Ä—É—á–Ω—É—é –≤–∞–ª–∏–¥–∞—Ü–∏—é...")
            
            # –†—É—á–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –∫–∞–∫ fallback
            init_data = await manual_validate_init_data(init_data_str, secret_key)
        
        if not init_data.user or not init_data.user.id:
            raise ValueError("User ID not found in parsed data")
        
        user_info = {
            "telegram_id": init_data.user.id,
            "first_name": init_data.user.first_name,
            "last_name": init_data.user.last_name or "",
            "username": init_data.user.username,
        }
        logger.info(f"–£—Å–ø–µ—à–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –¥–ª—è telegram_id: {user_info['telegram_id']}")

        # –ü–æ–ª—É—á–∞–µ–º —Ö–æ—Å—Ç –∏ —Å—Ö–µ–º—É –∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞, —á—Ç–æ–±—ã
        # –±—ç–∫–µ–Ω–¥ –º–æ–≥ —Å—Ç—Ä–æ–∏—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ URL
        host = request.headers.get('host')
        scheme = request.url.scheme

        profile_data = await django_api_service.get_or_create_user_profile(
            user_data=init_data.user,
            host=host,
            scheme=scheme
        )
        
        if not profile_data:
            logger.error(f"–°–µ—Ä–≤–∏—Å –Ω–µ —Å–º–æ–≥ –ø–æ–ª—É—á–∏—Ç—å –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª—å –¥–ª—è telegram_id: {user_info['telegram_id']}")
            raise HTTPException(status_code=502, detail="Backend service failed to process profile.")
            
        logger.info(f"–ü—Ä–æ—Ñ–∏–ª—å –¥–ª—è telegram_id: {user_info['telegram_id']} —É—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω/—Å–æ–∑–¥–∞–Ω.")
        logger.info(f"–í–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–µ –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª—è: {profile_data}")
        logger.info(f"üîç –í–û–ó–í–†–ê–©–ê–ï–ú–´–ô TELEGRAM_ID: {profile_data.get('telegram_id', 'NOT_FOUND')}")
        logger.info(f"–¢–∏–ø profile_data: {type(profile_data)}")
        logger.info(f"Avatar –≤ profile_data: {profile_data.get('avatar') if isinstance(profile_data, dict) else 'Not a dict'}")
        logger.info(f"–¢–∏–ø avatar –≤ profile_data: {type(profile_data.get('avatar')) if isinstance(profile_data, dict) else 'N/A'}")
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º cookie —Å telegram_id, —á—Ç–æ–±—ã —Å—Ç—Ä–∞–Ω–∏—Ü—ã –º–æ–≥–ª–∏ —Ä–µ–Ω–¥–µ—Ä–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å —Å–µ—Ä–≤–µ—Ä-—Å–∞–π–¥
        resp = JSONResponse(content=profile_data)
        try:
            tg_id_value = str(profile_data.get('telegram_id') or user_info['telegram_id'])
            resp.set_cookie(
                key="telegram_id",
                value=tg_id_value,
                max_age=365*24*60*60,
                httponly=False,
                samesite="lax"
            )
            logger.info(f"Cookie telegram_id set: {tg_id_value}")
        except Exception as cookie_err:
            logger.warning(f"Failed to set telegram_id cookie: {cookie_err}")
        return resp

    except (InvalidInitDataError, ExpiredInitDataError) as e:
        logger.warning(f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ initData: {e}")
        logger.warning(f"–ü–æ–ª–Ω—ã–π initData –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏: {init_data_str}")
        raise HTTPException(status_code=401, detail=f"Invalid initData: {e}")
    except (ValueError, ValidationError) as e:
        logger.warning(f"–û—à–∏–±–∫–∞ –≤ –¥–∞–Ω–Ω—ã—Ö initData: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        # –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–ª–Ω—É—é —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫—É –æ—à–∏–±–∫–∏
        logger.exception(f"–ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –≤ verify_init_data: {e}")
        raise HTTPException(status_code=500, detail="An internal server error occurred.")


@router.get("/profile/by-telegram/{telegram_id}/")
async def get_profile_by_telegram_id(telegram_id: int):
    """
    –ü—Ä–æ–∫—Å–∏—Ä—É–µ—Ç –∑–∞–ø—Ä–æ—Å –∫ Django API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è –ø–æ telegram_id.
    """
    logger.info(f"Fetching profile from Django for telegram_id: {telegram_id}")
    django_url = f"{settings.DJANGO_API_BASE_URL}/api/accounts/profile/by-telegram/{telegram_id}/"
    headers = {}  # –í—Ä–µ–º–µ–Ω–Ω–æ —É–±–∏—Ä–∞–µ–º —Ç–æ–∫–µ–Ω –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(django_url, headers=headers, timeout=10.0)
        
        if response.status_code == 200:
            return JSONResponse(content=response.json())
        else:
            logger.error(f"Error from Django API [get_profile_by_telegram_id]: {response.status_code} - {response.text}")
            raise HTTPException(status_code=response.status_code, detail=response.text)
            
    except httpx.RequestError as e:
        logger.error(f"Request error while contacting Django API: {e}")
        raise HTTPException(status_code=500, detail="Could not connect to backend service.")
    except Exception as e:
        logger.error(f"An unexpected error occurred in get_profile_by_telegram_id: {e}")
        raise HTTPException(status_code=500, detail="An internal server error occurred.")


# –£–¥–∞–ª–µ–Ω —Å—Ç–∞—Ä—ã–π handler /topics –±–µ–∑ telegram_id, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—É—é –≤–µ—Ä—Å–∏—é –Ω–∏–∂–µ

@router.get("/topic/{topic_id}")
async def get_topic(topic_id: int):
    subtopics = await fetch_subtopics_from_django(topic_id)
    return {"subtopics": subtopics}

@router.get("/subtopics/{subtopic_id}")
async def get_subtopic_with_user(subtopic_id: int, language: str = 'en', telegram_id: int | None = None):
    """–ü—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–µ—Ç–∞–ª–µ–π –ø–æ–¥—Ç–µ–º—ã (—Å –∑–∞–¥–∞—á–∞–º–∏) —Å –ø–µ—Ä–µ–¥–∞—á–µ–π telegram_id –¥–ª—è –æ—Ç–º–µ—Ç–∫–∏ —Ä–µ—à—ë–Ω–Ω—ã—Ö –∑–∞–¥–∞—á."""
    try:
        params = {'language': language}
        if telegram_id:
            params['telegram_id'] = telegram_id
        result = await django_api_service._make_request("GET", f"/api/subtopics/{subtopic_id}/", params=params)
        return result
    except Exception as e:
        logger.error(f"Error getting subtopic {subtopic_id}: {e}")
        raise HTTPException(status_code=502, detail="Failed to fetch subtopic from backend")
    
@router.post("/profile/{telegram_id}/update/")
async def update_profile(telegram_id: int, avatar: UploadFile = File(...)):
    """
    –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –∞–≤–∞—Ç–∞—Ä –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞ –∏ –ø–µ—Ä–µ—Å—ã–ª–∞–µ—Ç –µ–≥–æ –≤ Django-–±—ç–∫–µ–Ω–¥.
    """
    logger.info(f"Updating profile for telegram_id: {telegram_id}")
    
    django_update_url = f"{settings.DJANGO_API_BASE_URL}/api/accounts/profile/by-telegram/{telegram_id}/update/"
    headers = {}  # –í—Ä–µ–º–µ–Ω–Ω–æ —É–±–∏—Ä–∞–µ–º —Ç–æ–∫–µ–Ω –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    file_content = await avatar.read()
    files = {'avatar': (avatar.filename, file_content, avatar.content_type)}
    
    try:
        async with httpx.AsyncClient() as client:
            response = await client.patch(django_update_url, files=files, headers=headers, timeout=30.0)
            
        if response.status_code == 200:
            return JSONResponse(content=response.json(), status_code=response.status_code)
        else:
            raise HTTPException(status_code=response.status_code, detail=response.text)

    except Exception as e:
        raise HTTPException(status_code=500, detail="An internal server error occurred.")

@router.patch("/accounts/miniapp-users/update/{telegram_id}/")
async def update_miniapp_user_profile(telegram_id: int, request: Request):
    """
    –û–±–Ω–æ–≤–ª—è–µ—Ç –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è MiniApp, –≤–∫–ª—é—á–∞—è –∑–∞–≥—Ä—É–∑–∫—É –∞–≤–∞—Ç–∞—Ä–∞.
    –ü—Ä–æ–∫—Å–∏—Ä—É–µ—Ç –∑–∞–ø—Ä–æ—Å—ã –≤ Django API.
    """
    logger.info(f"Updating MiniApp user profile for telegram_id: {telegram_id}")
    
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞
        content_type = request.headers.get("content-type", "")
        
        if "multipart/form-data" in content_type:
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É —Ñ–∞–π–ª–∞ –∏ –¥—Ä—É–≥–∏—Ö –¥–∞–Ω–Ω—ã—Ö
            form_data = await request.form()
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Django API
            django_update_url = f"{settings.DJANGO_API_BASE_URL}/api/accounts/miniapp-users/update/{telegram_id}/"
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Ñ–∞–π–ª—ã –∏ –¥–∞–Ω–Ω—ã–µ
            files = {}
            data = {}
            
            for key, value in form_data.items():
                if hasattr(value, 'read'):  # –≠—Ç–æ —Ñ–∞–π–ª
                    file_content = await value.read()
                    files[key] = (value.filename, file_content, value.content_type)
                else:  # –≠—Ç–æ –æ–±—ã—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                    data[key] = value
            
            async with httpx.AsyncClient() as client:
                response = await client.patch(
                    django_update_url, 
                    files=files if files else None,
                    data=data if data else None,
                    timeout=30.0
                )
                    
            if response.status_code == 200:
                return JSONResponse(content=response.json(), status_code=response.status_code)
            else:
                logger.error(f"Django API error: {response.status_code} - {response.text}")
                raise HTTPException(status_code=response.status_code, detail=response.text)
                
        else:
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º JSON –¥–∞–Ω–Ω—ã–µ
            profile_data = await request.json()
            logger.info(f"Received profile data: {profile_data}")
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ Django API
            django_update_url = f"{settings.DJANGO_API_BASE_URL}/api/accounts/miniapp-users/update/{telegram_id}/"
            
            async with httpx.AsyncClient() as client:
                response = await client.patch(
                    django_update_url,
                    json=profile_data,
                    timeout=30.0
                )
            
            if response.status_code == 200:
                return JSONResponse(content=response.json())
            else:
                logger.error(f"Django API error: {response.status_code} - {response.text}")
                raise HTTPException(status_code=response.status_code, detail=response.text)
            
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in request: {e}")
        raise HTTPException(status_code=400, detail="Invalid JSON data")
    except Exception as e:
        logger.error(f"Error updating profile: {e}")
        logger.error(f"Error type: {type(e)}")
        import traceback
        logger.error(f"Traceback: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail="An internal server error occurred.")

@router.patch("/profile/{telegram_id}/update/")
async def update_profile_json(telegram_id: int, request: Request):
    """
    –£–°–¢–ê–†–ï–í–®–ò–ô ENDPOINT - –æ—Å—Ç–∞–≤–ª–µ–Ω –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏.
    –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç –Ω–∞ –Ω–æ–≤—ã–π endpoint.
    """
    logger.warning(f"Using deprecated endpoint /profile/{telegram_id}/update/ - redirecting to new endpoint")
    return await update_miniapp_user_profile(telegram_id, request)

# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Django API
async def fetch_topics_from_django(search: str = None):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ç–µ–º –∏–∑ Django API"""
    try:
        topics = await django_api_service.get_topics(search=search)
        return topics
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ç–µ–º: {e}")
        return []

async def fetch_subtopics_from_django(topic_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–¥—Ç–µ–º –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —Ç–µ–º—ã –∏–∑ Django API"""
    try:
        subtopics = await django_api_service.get_subtopics(topic_id=topic_id)
        return subtopics
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–¥—Ç–µ–º –¥–ª—è —Ç–µ–º—ã {topic_id}: {e}")
        return []

# –î—Ä—É–≥–∏–µ API-—ç–Ω–¥–ø–æ–∏–Ω—Ç—ã (test-api, button-click, profile/stats, –∏ —Ç.–¥.)
# –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å—é–¥–∞ –ø–æ –∞–Ω–∞–ª–æ–≥–∏–∏. 

async def get_user_profile(request_data: UserProfileRequest):
    try:
        logger.info(f"–ü–æ–ª—É—á–µ–Ω –∑–∞–ø—Ä–æ—Å –ø—Ä–æ—Ñ–∏–ª—è. InitData: {request_data.initData[:150]}...")
        
        user_info = {}
        try:
            # –°–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è –≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ
            validated_data = authenticator.validate(request_data.initData)
            user = validated_data.user
            user_info = {
                "telegram_id": user.id,
                "first_name": user.first_name,
                "last_name": user.last_name or "",
                "username": user.username
            }
            logger.info(f"–í–∞–ª–∏–¥–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞. –î–∞–Ω–Ω—ã–µ: {user_info}")
        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ initData: {e}. –ü—Ä–æ–±—É–µ–º —Ä—É—á–Ω–æ–π –ø–∞—Ä—Å–∏–Ω–≥.")
            # –ï—Å–ª–∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å, –ø–∞—Ä—Å–∏–º –≤—Ä—É—á–Ω—É—é –∫–∞–∫ fallback
            decoded_data = urllib.parse.unquote(request_data.initData)
            try:
                user_json_match = re.search(r'user=({.*?})(&|$)', decoded_data)
                if user_json_match:
                    user_data = json.loads(user_json_match.group(1))
                    user_info = {
                        "telegram_id": user_data.get("id"),
                        "first_name": user_data.get("first_name"),
                        "last_name": user_data.get("last_name", ""),
                        "username": user_data.get("username")
                    }
                    logger.info(f"–†—É—á–Ω–æ–π –ø–∞—Ä—Å–∏–Ω–≥ —É—Å–ø–µ—à–µ–Ω. –î–∞–Ω–Ω—ã–µ: {user_info}")
                if not user_info.get("telegram_id"):
                    raise ValueError("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å telegram_id")
            except Exception as parse_error:
                logger.error(f"–ü–æ–ª–Ω–∞—è –æ—à–∏–±–∫–∞ —Ä—É—á–Ω–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞: {parse_error}")
                raise HTTPException(status_code=400, detail="–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å initData.")

        # 3. –ó–∞–ø—Ä–æ—Å –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è –≤ Django
        profile_data = await django_api_service.get_or_create_user_profile(user_info)
        logger.info(f"–û—Ç–≤–µ—Ç –æ—Ç Django: {profile_data}")
        
        # 4. –í–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª—è
        return profile_data

    except ValidationError as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ Pydantic: {e}")
        raise HTTPException(status_code=400, detail=f"Invalid Request Body: {e}")
    except Exception as e:
        logger.exception("–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è")
        raise HTTPException(status_code=500, detail="Internal server error")

# –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —ç–Ω–¥–ø–æ–∏–Ω—Ç–∞ –≤ —Ä–æ—É—Ç–µ—Ä–µ
router.add_api_route("/profile", get_user_profile, methods=["POST"])

class LanguageChangeRequest(BaseModel):
    language: str

@router.post("/change-language")
async def change_language(request: LanguageChangeRequest, response: Response):
    """API endpoint –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —è–∑—ã–∫–∞"""
    from services.localization import localization_service
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –ª–∏ —è–∑—ã–∫
    if request.language not in localization_service.get_supported_languages():
        return {"success": False, "error": "Unsupported language"}
    
    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —è–∑—ã–∫
    localization_service.set_language(request.language)
    
    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º cookie –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—ã–±–æ—Ä–∞
    response.set_cookie(
        key="selected_language", 
        value=request.language,
        max_age=365*24*60*60,  # 1 –≥–æ–¥
        httponly=False,  # –†–∞–∑—Ä–µ—à–∞–µ–º –¥–æ—Å—Ç—É–ø –∏–∑ JavaScript
        samesite="lax"
    )
    
    # –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –ø–µ—Ä–µ–≤–æ–¥—ã
    translations = localization_service.get_all_texts(request.language)
    
    return {
        "success": True,
        "language": request.language,
        "translations": translations,
        "supported_languages": localization_service.get_supported_languages()
    }

@router.get("/topics")
async def get_topics(search: str = None, language: str = 'en', telegram_id: int | None = None):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ç–µ–º —Å –ø–æ–∏—Å–∫–æ–º –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (telegram_id)"""
    from services.django_api_service import django_api_service
    
    try:
        logger.info(f"/api/topics called: search={search}, language={language}, telegram_id={telegram_id}")
        params = {'language': language}
        if search:
            params['search'] = search
        if telegram_id:
            params['telegram_id'] = telegram_id
            
        result = await django_api_service._make_request("GET", "/api/simple/", params=params)
        logger.info(f"/api/topics returned {len(result) if isinstance(result, list) else 'non-list'} items")
        return result if isinstance(result, list) else []
    except Exception as e:
        logger.error(f"Error getting topics: {e}")
        return []

@router.get("/stripe-publishable-key")
async def get_stripe_publishable_key():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–ª—é—á–∞ Stripe —á–µ—Ä–µ–∑ Django API"""
    from services.django_api_service import django_api_service
    
    try:
        result = await django_api_service._make_request("GET", "/api/stripe-publishable-key/")
        return result
    except Exception as e:
        logger.error(f"Error getting Stripe key: {e}")
        return {"success": False, "message": "Error getting Stripe key"}

@router.post("/create-payment-intent")
async def create_payment_intent_proxy(request_data: dict):
    """–°–æ–∑–¥–∞–Ω–∏–µ Payment Intent —á–µ—Ä–µ–∑ Django API"""
    from services.donation_service import DonationService
    
    try:
        donation_service = DonationService()
        result = await donation_service.create_payment_intent(
            amount=request_data.get('amount'),
            currency=request_data.get('currency', 'usd'),
            email=request_data.get('email', ''),
            name=request_data.get('name', '')
        )
        return result
    except Exception as e:
        logger.error(f"Error creating payment intent: {e}")
        return {"success": False, "message": "Error creating payment intent"}

@router.post("/confirm-payment")
async def confirm_payment_proxy(request_data: dict):
    """–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ —á–µ—Ä–µ–∑ Django API"""
    from services.donation_service import DonationService
    
    try:
        donation_service = DonationService()
        result = await donation_service.confirm_payment(
            payment_intent_id=request_data.get('payment_intent_id'),
            payment_method_id=request_data.get('payment_method_id', '')
        )
        return result
    except Exception as e:
        logger.error(f"Error confirming payment: {e}")
        return {"success": False, "message": "Error confirming payment"}

@router.get("/robots.txt", response_class=PlainTextResponse)
async def robots_txt():
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç robots.txt –¥–ª—è –º–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.
    –ë–ª–æ–∫–∏—Ä—É–µ—Ç –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—é –ø–æ–∏—Å–∫–æ–≤—ã–º–∏ —Å–∏—Å—Ç–µ–º–∞–º–∏.
    """
    robots_content = """# Robots.txt –¥–ª—è Telegram Mini App
# –≠—Ç–æ—Ç robots.txt –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—é –º–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –ø–æ–∏—Å–∫–æ–≤—ã–º–∏ —Å–∏—Å—Ç–µ–º–∞–º–∏

User-agent: *
Disallow: /

# –ó–∞–ø—Ä–µ—â–∞–µ–º –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—é –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤ –∏ –ø–∞–ø–æ–∫
Disallow: /static/
Disallow: /media/
Disallow: /api/
Disallow: /admin/

# –ù–µ—Ç sitemap –¥–ª—è –º–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
# –û—Å–Ω–æ–≤–Ω–æ–π sitemap –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ quiz-code.com

# –ü—Ä–∏—á–∏–Ω–∞: Telegram Mini App –Ω–µ –¥–æ–ª–∂–µ–Ω –∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞—Ç—å—Å—è –ø–æ–∏—Å–∫–æ–≤–∏–∫–∞–º–∏
# —Ç–∞–∫ –∫–∞–∫ –æ–Ω –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω —Ç–æ–ª—å–∫–æ –¥–ª—è —Ä–∞–±–æ—Ç—ã –≤–Ω—É—Ç—Ä–∏ Telegram"""
    
    return robots_content


async def manual_validate_init_data(init_data_str: str, secret_key: bytes):
    """
    –†—É—á–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è initData –∫–∞–∫ fallback, –µ—Å–ª–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç.
    """
    import urllib.parse
    import json
    from dataclasses import dataclass
    
    @dataclass
    class WebAppUser:
        id: int
        first_name: str
        last_name: str = None
        username: str = None
        language_code: str = None
        photo_url: str = None
    
    @dataclass
    class WebAppInitData:
        user: WebAppUser
        query_id: str = None
        auth_date: int = None
    
    try:
        # –ü–∞—Ä—Å–∏–º initData
        params = dict(urllib.parse.parse_qsl(init_data_str))
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
        if 'user' not in params:
            raise ValueError("User data not found in initData")
        
        # –î–µ–∫–æ–¥–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_data = json.loads(urllib.parse.unquote(params['user']))
        
        # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user = WebAppUser(
            id=user_data['id'],
            first_name=user_data.get('first_name', ''),
            last_name=user_data.get('last_name'),
            username=user_data.get('username'),
            language_code=user_data.get('language_code'),
            photo_url=user_data.get('photo_url')
        )
        
        # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç initData
        init_data = WebAppInitData(
            user=user,
            query_id=params.get('query_id'),
            auth_date=int(params.get('auth_date', 0))
        )
        
        logger.info(f"–†—É—á–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.id}")
        logger.info(f"Photo URL –∏–∑ Telegram: {user.photo_url}")
        logger.info(f"–í—Å–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ Telegram: {user_data}")
        return init_data
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Ä—É—á–Ω–æ–π –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {e}")
        raise ValueError(f"Manual validation failed: {e}") 

@router.post("/tasks/{task_id}/submit-mini-app")
async def submit_task_answer(task_id: int, request: Request):
    """
    –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –æ—Ç–≤–µ—Ç –Ω–∞ –∑–∞–¥–∞—á—É –∏–∑ –º–∏–Ω–∏-–∞–ø–ø–∞ –≤ Django API.
    """
    logger.info(f"üéØ –ü–û–õ–£–ß–ï–ù –ó–ê–ü–†–û–° –ù–ê –û–¢–ü–†–ê–í–ö–£ –û–¢–í–ï–¢–ê –¥–ª—è task_id: {task_id}")
    logger.info(f"üéØ URL: {request.url}")
    logger.info(f"üéØ Method: {request.method}")
    logger.info(f"üéØ Headers: {dict(request.headers)}")
    logger.info(f"üéØ User-Agent: {request.headers.get('user-agent', 'Unknown')}")
    logger.info(f"üéØ X-Forwarded-For: {request.headers.get('x-forwarded-for', 'Unknown')}")
    logger.info(f"üéØ Referer: {request.headers.get('referer', 'Unknown')}")
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
        data = await request.json()
        logger.info(f"Received data: {data}")
        telegram_id = data.get('telegram_id')
        answer = data.get('answer')
        
        logger.info(f"Extracted telegram_id: {telegram_id}, answer: {answer}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ initData –≤ —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞
        init_data_from_body = data.get('initData')
        if init_data_from_body:
            logger.info(f"üîç –ù–∞–π–¥–µ–Ω initData –≤ —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞: {init_data_from_body[:100]}...")
        else:
            logger.info(f"üîç initData –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π telegram_id
        if not telegram_id:
            # –ü–æ–ø—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å telegram_id –∏–∑ initData –≤ —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞
            if init_data_from_body:
                logger.info(f"üîç –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å telegram_id –∏–∑ initData –≤ —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞")
                try:
                    # –í–∞–ª–∏–¥–∏—Ä—É–µ–º initData –∏ –ø–æ–ª—É—á–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π telegram_id
                    validated_data = authenticator.validate(init_data_from_body)
                    telegram_id = validated_data.user.id
                    logger.info(f"‚úÖ –ü–æ–ª—É—á–µ–Ω telegram_id –∏–∑ initData: {telegram_id}")
                except Exception as validation_error:
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ initData: {validation_error}")
            
            # –ï—Å–ª–∏ –≤—Å–µ –µ—â–µ –Ω–µ—Ç telegram_id, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É
            if not telegram_id:
                logger.error("telegram_id is missing")
                raise HTTPException(status_code=400, detail="telegram_id is required")
        
        if not answer:
            logger.error("answer is missing")
            raise HTTPException(status_code=400, detail="answer is required")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –≤ Django API
        django_url = f"{settings.DJANGO_API_BASE_URL}/api/tasks/{task_id}/submit-mini-app/"
        payload = {
            'telegram_id': telegram_id,
            'answer': answer
        }
        
        async with httpx.AsyncClient() as client:
            response = await client.post(django_url, json=payload, timeout=10.0)
        
        if response.status_code == 200:
            return JSONResponse(content=response.json())
        else:
            logger.error(f"Error from Django API: {response.status_code} - {response.text}")
            # –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å-–∫–æ–¥ Django –¥–∞–ª—å—à–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 409 –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏)
            raise HTTPException(status_code=response.status_code, detail=response.text)
            
    except httpx.RequestError as e:
        logger.error(f"Request error while contacting Django API: {e}")
        raise HTTPException(status_code=500, detail="Could not connect to backend service.")
    except HTTPException as e:
        # –ù–µ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º HTTPException –∏ –Ω–µ –ø—Ä–µ–≤—Ä–∞—â–∞–µ–º –µ–≥–æ –≤ 500
        raise e
    except Exception as e:
        logger.error(f"An unexpected error occurred: {e}")
        raise HTTPException(status_code=500, detail="An internal server error occurred.")