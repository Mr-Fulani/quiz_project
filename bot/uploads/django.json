{
  "tasks": [
    {
      "topic": "Python",
      "subtopic": "Collections",
      "description": "Understanding Django model field behavior.",
      "difficulty": "medium",
      "translations": [
        {
          "language": "en",
          "question": "from django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n    price = models.DecimalField(max_digits=10, decimal_places=2)\n    created_at = models.DateTimeField(auto_now_add=True)\n\nproduct = Product(name=\"Laptop\", price=999.99)\nprint(product.created_at is None)",
          "answers": ["True", "False", "Error"],
          "correct_answer": "True",
          "explanation": "The 'created_at' field is only populated when the object is saved to the database. Until 'product.save()' is called, 'created_at' remains None."
        },
        {
          "language": "ru",
          "question": "from django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n    price = models.DecimalField(max_digits=10, decimal_places=2)\n    created_at = models.DateTimeField(auto_now_add=True)\n\nproduct = Product(name=\"Laptop\", price=999.99)\nprint(product.created_at is None)",
          "answers": ["True", "False", "Ошибка"],
          "correct_answer": "True",
          "explanation": "Поле 'created_at' заполняется только при сохранении объекта в базе данных. Пока не вызван 'product.save()', значение остаётся None."
        }
      ]
    },
    {
      "topic": "Python",
      "subtopic": "Collections",
      "description": "Understanding ForeignKey relationships.",
      "difficulty": "medium",
      "translations": [
        {
          "language": "en",
          "question": "from django.db import models\n\nclass Author(models.Model):\n    name = models.CharField(max_length=100)\n\nclass Book(models.Model):\n    title = models.CharField(max_length=100)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n\nauthor = Author.objects.create(name=\"J.K. Rowling\")\nbook = Book.objects.create(title=\"Harry Potter\", author=author)\n\nprint(book.author.name)",
          "answers": ["J.K. Rowling", "None", "Error"],
          "correct_answer": "J.K. Rowling",
          "explanation": "When a Book object is created with an Author, accessing 'book.author.name' returns the author's name."
        },
        {
          "language": "ru",
          "question": "from django.db import models\n\nclass Author(models.Model):\n    name = models.CharField(max_length=100)\n\nclass Book(models.Model):\n    title = models.CharField(max_length=100)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n\nauthor = Author.objects.create(name=\"J.K. Rowling\")\nbook = Book.objects.create(title=\"Harry Potter\", author=author)\n\nprint(book.author.name)",
          "answers": ["J.K. Rowling", "None", "Ошибка"],
          "correct_answer": "J.K. Rowling",
          "explanation": "При создании книги 'book' с автором 'author', доступ к 'book.author.name' возвращает имя автора."
        }
      ]
    },
    {
      "topic": "Python",
      "subtopic": "Collections",
      "description": "Working with ManyToManyField relationships.",
      "difficulty": "medium",
      "translations": [
        {
          "language": "en",
          "question": "from django.db import models\n\nclass Tag(models.Model):\n    name = models.CharField(max_length=50)\n\nclass Post(models.Model):\n    title = models.CharField(max_length=100)\n    tags = models.ManyToManyField(Tag)\n\npost = Post.objects.create(title=\"Django Models\")\ntag = Tag.objects.create(name=\"Python\")\npost.tags.add(tag)\n\nprint(post.tags.count())",
          "answers": ["1", "0", "Error"],
          "correct_answer": "1",
          "explanation": "Using ManyToManyField, 'post.tags.add(tag)' creates a relation, so 'post.tags.count()' returns 1."
        },
        {
          "language": "ru",
          "question": "from django.db import models\n\nclass Tag(models.Model):\n    name = models.CharField(max_length=50)\n\nclass Post(models.Model):\n    title = models.CharField(max_length=100)\n    tags = models.ManyToManyField(Tag)\n\npost = Post.objects.create(title=\"Django Models\")\ntag = Tag.objects.create(name=\"Python\")\npost.tags.add(tag)\n\nprint(post.tags.count())",
          "answers": ["1", "0", "Ошибка"],
          "correct_answer": "1",
          "explanation": "При использовании ManyToManyField, 'post.tags.add(tag)' создаёт связь, поэтому 'post.tags.count()' возвращает 1."
        }
      ]
    },
    {
      "topic": "Python",
      "subtopic": "Collections",
      "description": "Defining a custom method in a Django model.",
      "difficulty": "medium",
      "translations": [
        {
          "language": "en",
          "question": "from django.db import models\n\nclass UserProfile(models.Model):\n    name = models.CharField(max_length=100)\n    age = models.IntegerField()\n\n    def is_adult(self):\n        return self.age >= 18\n\nuser = UserProfile(name=\"Alice\", age=20)\nprint(user.is_adult())",
          "answers": ["True", "False", "Error"],
          "correct_answer": "True",
          "explanation": "The 'is_adult()' method returns True if the age is 18 or greater."
        },
        {
          "language": "ru",
          "question": "from django.db import models\n\nclass UserProfile(models.Model):\n    name = models.CharField(max_length=100)\n    age = models.IntegerField()\n\n    def is_adult(self):\n        return self.age >= 18\n\nuser = UserProfile(name=\"Alice\", age=20)\nprint(user.is_adult())",
          "answers": ["True", "False", "Ошибка"],
          "correct_answer": "True",
          "explanation": "Метод 'is_adult()' возвращает True, если возраст 18 лет и больше."
        }
      ]
    }
  ]
}